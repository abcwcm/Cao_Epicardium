---
title: "Monocle3"
author: "Friederike Dündar"
date: "8/12/2019"
output:
  pdf_document:
    toc: yes
  html_document:
    toc: yes
    code_folding: hide
editor_options:
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, cache = TRUE)
```

```
conda create --name monocle --clone biocdevel
conda install -c r r-units 
conda install -c r r-lmtest  
conda install -c r r-sf
conda install -c r r-classInt
conda install -c r r-spdep
conda install -c r r-matrix 

~/miniconda3/envs/monocle/bin/R

install.packages("reticulate")
reticulate::py_install("louvain")

#devtools::install_github('cole-trapnell-lab/monocle3') ## couldn't get this to work

# cloned the repo
# in R: 
devtools::load_all("monocle3")

```

## 3dpa, epicardial cells (*tcf21* high) only

```{r monocle_prep_3dpa_epiClustersOnly, eval=FALSE}
## ADD LOAD FROM BOX
sce <- readRDS("sce_3dpa_ScTransform_ClustRemoved_2019-07.rds")
cd <- colData(sce)[, c("Sample", "ori_barcodes", "cell_names", "condition", "clusters_d3.03", "res.01")]  
rd <- rowData(sce)[, c("id","symbol")]
rd$gene_short_name <- rd$symbol

## construct cds
cds <- new_cell_data_set(counts(sce),
                         cell_metadata = cd,
                         gene_metadata = rd)

cds <- preprocess_cds(cds, num_dim = 100)

set.seed(123)
cds <- reduce_dimension(cds, reduction_method = "UMAP", preprocess_method = "PCA")
cds <- cluster_cells(cds, reduction_method = "UMAP") # can be accessed:  clusters(cds)
cds <- learn_graph(cds)
#cds <- order_cells(cds) ## this needs shiny unless we specify the root nodes of the trajectory graph

get_earliest_principal_node <- function(cds, partition=NULL){
    
    if(!is.null(partition)){
        cell_ids <- which(partitions(cds) == partition)
    }else{
        cell_ids <- colnames(cds)
    }

  closest_vertex <-
    cds@principal_graph_aux[["UMAP"]]$pr_graph_cell_proj_closest_vertex
  closest_vertex <- as.matrix(closest_vertex[colnames(cds), ])
  
  root_pr_nodes <-
    igraph::V(principal_graph(cds)[["UMAP"]])$name[as.numeric(names
      (which.max(table(closest_vertex[cell_ids,]))))]

  root_pr_nodes
}

root_cells <- unlist(lapply(levels(partitions(cds)), function(x) get_earliest_principal_node(cds, partition = x)))
cds <- order_cells(cds, root_pr_nodes = root_cells)
saveRDS(cds, file = "monocle_3dpa_clstRemoved.rds")
```

From monocle3' documentation:

>The black lines show the structure of the graph. Note that the graph is not fully connected: cells in different partitions are in distinct components of the graph.

>The circles with numbers in them denote special points within the graph. Each leaf, denoted by light gray circles, corresponds to a different outcome (i.e. cell fate) of the trajectory. Black circles indicate branch nodes, in which cells can travel to one of several outcomes.

>Note that some of the cells are gray. This means they have infinite pseudotime, because they were not reachable from the root nodes that were picked. In general, any cell on a partition that lacks a root node will be assigned an infinite pseudotime. In general, you should choose at least one root per partition.

Coloring by our original clusters:

```{r eval=FALSE}
## load SCE
scf <- readRDS(file = "sce_CellGeneFiltWithScTransformBatchCorrect_ClustRemoved_2019-07.rds")

## extract cluster information (epicardial cells only, but all conditions)
cd_old <- colData(scf)[, c("Sample","cell_names","clusters.03")] %>% as.data.frame %>% as.data.table
cd_new <- colData(cds) %>% as.data.table
cd_combined <- cd_old[cd_new, on = "cell_names"]
## add our customized labels
our_labs <- data.table(clusters.03 = as.character(0:6),
                       clust.label = c("periv.btg2", "periv.vegfaa", "aldh1a2", "adh8", "3dpa-specific", "ribo", "7dpa-specific"))
cd_combined <- our_labs[cd_combined, on = "clusters.03"]     
cd_combined <- as.data.frame(cd_combined)
rownames(cd_combined) <- cd_combined$cell_names
colData(cds)$clusters.03 <- cd_combined[colnames(cds),]$clusters.03
colData(cds)$clust.labels <- factor(cd_combined[colnames(cds),]$clust.label, levels = c("periv.btg2", "periv.vegfaa", "aldh1a2", "adh8", "3dpa-specific", "ribo", "7dpa-specific"), ordered = TRUE)

## define colors
cluster_cols <- ABCutilities:::fx.get_palette_ABC("paired_pal")[seq_len(length(unique(cd_combined$clust.label)))]


## use Monocle's printing function
png("monocle3_clusters03.png", width = 900)
plot_cells(cds, color_cells_by = "clust.labels", label_cell_groups=FALSE,label_leaves=FALSE,label_branch_points=FALSE,graph_label_size=5, cell_size = 1) +
  scale_color_manual(values = cluster_cols)
dev.off()

png("monocle3_markerGenes.png", width = 1400)
plot_cells(cds, genes = c("top2a","aldh1a2","fn1a"), label_cell_groups=FALSE,label_leaves=FALSE,label_branch_points=FALSE,graph_label_size=5, cell_size = 1)
dev.off()
```

### DE analysis

Which genes have cluster-dependent expression?

```{r DE_following_clusters, eval=FALSE}
gene_fits <- fit_models(cds, model_formula_str = "~clusters.03")
fit_coefs = coefficient_table(gene_fits)
## coefficient_table() calculates tests each coefficient for whether it is significantly different than zero under the Wald test. By default, coefficient_table() adjusts these p-values for multiple hypothesis testing using the method of Benjamini and Hochberg. 
subset(fit_coefs, q_value <= 0.05 & term != "(Intercept)")
# A tibble: 7,568 x 12
#   id    symbol gene_short_name status term  estimate std_err test_val  p_value
#   <chr> <chr>  <chr>           <chr>  <chr>    <dbl>   <dbl>    <dbl>    <dbl>
# 1 ENSD… rpl18a rpl18a          OK     clus…    0.198  0.0216     9.17 8.10e-20
# 2 ENSD… rpl18a rpl18a          OK     clus…   -0.196  0.0188   -10.4  4.51e-25
# 3 ENSD… rpl18a rpl18a          OK     clus…    0.445  0.0317    14.0  1.35e-43
# 4 ENSD… rpl18a rpl18a          OK     clus…    0.233  0.0406     5.73 1.09e- 8
# 5 ENSD… nap1l1 nap1l1          OK     clus…    0.502  0.0769     6.53 7.30e-11
# 6 ENSD… nap1l1 nap1l1          OK     clus…    0.428  0.0720     5.94 3.08e- 9
# 7 ENSD… nap1l1 nap1l1          OK     clus…    0.930  0.0671    13.9  1.50e-42
# 8 ENSD… creb3… creb3l2         OK     clus…   -0.464  0.0773    -6.00 2.13e- 9
# 9 ENSD… creb3… creb3l2         OK     clus…   -0.947  0.0814   -11.6  1.06e-30
#10 ENSD… creb3… creb3l2         OK     clus…   -0.427  0.0714    -5.98 2.48e- 9
# … with 7,558 more rows, and 3 more variables: normalized_effect <dbl>,
#   model_component <chr>, q_value <dbl>
```


Which genes change along pseudotime?

>How do we find the genes that are differentially expressed on the different paths through the trajectory?
>How do we find the ones that are restricted to the beginning of the trajectory? Or excluded from it?
Once again, we turn to graph_test(), this time passing it neighbor_graph="principal_graph", which tells it to **test whether cells at similar positions on the trajectory have correlated expression**:

```{r genes_changing_along_pseudotime, eval=FALSE}
cds_pr_test_res = graph_test(cds, neighbor_graph="principal_graph", cores=4)
saveRDS(cds_pr_test_res, file = "monocle3_graphTestResults_pseudotime_dpa3_clstRemoved.rds")
cds_pr_test_res <- cds_pr_test_res[order(cds_pr_test_res$q_value),]

## extract genes of interest
pr_deg_ids = row.names(subset(cds_pr_test_res, q_value < 0.05))

## collect the trajectory-variable genes into module
## essentially runs UMAP on the genes (as opposed to the cells) and then groups them into
## modules using Louvain community analysis
gene_module_df <- find_gene_modules(cds[pr_deg_ids,], resolution = 1e-2, cores = 1, n_sgd_threads = 1) ## currently running into segfaults


```

Monocle 3 introduces (...) draws on a powerful technique in spatial correlation analysis, the Moran’s I test. [Ref](http://cole-trapnell-lab.github.io/monocle-release/monocle3/)

>Moran’s I is a measure of multi-directional and multi-dimensional spatial autocorrelation.
The statistic tells you whether cells at nearby positions on a trajectory will have similar (or dissimilar) expression levels for the gene being tested.
Although both Pearson correlation and Moran’s I ranges from -1 to 1, the interpretation of Moran’s I is slightly different: +1 means that nearby cells will have perfectly similar expression (as in the right panel below); 0 represents no correlation (center), and -1 means that neighboring cells will be *anti-correlated* (left). 

```{r plot_genes_changing_along_pseudotime, eval=FALSE}
#plot_cells(cds,
#           genes=gene_module_df %>% filter(module %in% c(29,20, 11,22)),
#           label_cell_groups=FALSE,
#           show_trajectory_graph=FALSE)

## extract top genes from graph_test result
goi <- subset(cds_pr_test_res, q_value <= 0.05) %>% rownames %>% head(., n = 30)
goi <- goi[!grepl("^rp[ls]", goi)] ## removing ribosomal genes because they didn't really have interesting patterns

png("monocle_topGenesPseudotime.png", height = 2700, width = 700)
plot_genes_in_pseudotime(cds[rowData(cds)$gene_short_name %in% goi, ],
                         color_cells_by="clust.labels",
                         min_expr=0.5) +
    scale_color_manual(values = cluster_cols)
dev.off()

```

![](monocle_topGenesPseudotime.png)

```{r load_data, cache.lazy=FALSE, message=FALSE}
library(magrittr)
library(data.table)
library(scater)
library(ggplot2) ; theme_set(theme_bw(base_size = 16))

scf <- readRDS(file = "sce_CellGeneFiltWithScTransformBatchCorrect_ClustRemoved_2019-07.rds")

cd_old <- colData(scf)[, c("Sample","cell_names","clusters.03")] %>% as.data.frame %>% as.data.table
## add our customized labels
our_labs <- data.table(clusters.03 = as.character(0:6),
                       clust.label = c("periv.btg2", "periv.vegfaa", "aldh1a2", "adh8", "3dpa-specific", "ribo", "7dpa-specific"))
cd_combined <- our_labs[cd_old, on = "clusters.03"]     
cd_combined <- as.data.frame(cd_combined)
rownames(cd_combined) <- cd_combined$cell_names
colData(scf)$clust.labels <- factor(cd_combined[colnames(scf),]$clust.label, levels = c("periv.btg2", "periv.vegfaa", "aldh1a2", "adh8", "3dpa-specific", "ribo", "7dpa-specific"), ordered = TRUE)

cluster_cols <- ABCutilities:::fx.get_palette_ABC("paired_pal")[seq_len(length(unique(cd_combined$clust.label)))]
```

```{r umap_3dpa_pseudotimeMarkers, fig.width = 12, fig.height = 7}
goi <- c("ap1s1","atp5f1c","copg2","dcn","hsd11b2","hsp90b1","hspa5","hypk","lamb1b","mdka", "sat1a.2")
for(i in goi){
  P <- scABC2::plot_reducedDim_from_sce(scf, which_reddim = "umap_scTransformBatch", which_pcs = c(1:2),
                         color_by = i, 
                         exprs_values = "log1p_sctransform.batch",
                         add_cell_info = "condition",
                         label_by = "clusters.03",
                         alpha = .3, set_colors = TRUE,
                        size_by = .5, remove_rug = TRUE) +
    facet_wrap(~condition) + theme(legend.position = "bottom") + ggtitle(i)
  print(P)
}
```


# Session info

```
R version 3.6.1 (2019-07-05)
Platform: x86_64-conda_cos6-linux-gnu (64-bit)
Running under: Red Hat Enterprise Linux Server release 6.3 (Santiago)
  
Matrix products: default
BLAS/LAPACK: /pbtech_mounts/homes022/frd2007/miniconda3/envs/monocle/lib/libopenblasp-r0.3.6.so
  
locale:
 [1] LC_CTYPE=en_US.UTF-8       LC_NUMERIC=C
 [3] LC_TIME=en_US.UTF-8        LC_COLLATE=en_US.UTF-8
 [5] LC_MONETARY=en_US.UTF-8    LC_MESSAGES=en_US.UTF-8
 [7] LC_PAPER=en_US.UTF-8       LC_NAME=C
 [9] LC_ADDRESS=C               LC_TELEPHONE=C
[11] LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C       

attached base packages:
[1] stats4    parallel  stats     graphics  grDevices utils     datasets 
[8] methods   base     

other attached packages:
 [1] monocle3_0.1.3              testthat_2.2.1             
 [3] SingleCellExperiment_1.7.4  SummarizedExperiment_1.15.6
 [5] DelayedArray_0.11.4         BiocParallel_1.19.0        
 [7] matrixStats_0.54.0          GenomicRanges_1.37.14      
 [9] GenomeInfoDb_1.21.1         IRanges_2.19.10            
[11] S4Vectors_0.23.17           Biobase_2.45.0             
[13] BiocGenerics_0.31.5        

loaded via a namespace (and not attached):
  [1] Rtsne_0.15               colorspace_1.4-1         deldir_0.1-23           
  [4] grr_0.9.5                pryr_0.1.4               class_7.3-15            
  [7] rprojroot_1.3-2          XVector_0.25.0           fs_1.3.1                
 [10] rstudioapi_0.10          proxy_0.4-23             listenv_0.7.0           
 [13] furrr_0.1.0              remotes_2.1.0            ggrepel_0.8.1           
 [16] splines_3.6.1            codetools_0.2-16         pscl_1.5.2              
 [19] pkgload_1.0.2            speedglm_0.3-2           jsonlite_1.6            
 [22] RhpcBLASctl_0.18-205     uwot_0.1.3               pheatmap_1.0.12         
 [25] shiny_1.3.2              compiler_3.6.1           httr_1.4.1              
 [28] backports_1.1.4          assertthat_0.2.1         Matrix_1.2-17           
 [31] lazyeval_0.2.2           limma_3.41.15            cli_1.1.0               
 [34] later_0.8.0              htmltools_0.3.6          prettyunits_1.0.2       
 [37] tools_3.6.1              igraph_1.2.4.1           coda_0.19-3             
 [40] gtable_0.3.0             glue_1.3.1               GenomeInfoDbData_1.2.1  
 [43] RANN_2.6.1               reshape2_1.4.3           dplyr_0.8.3             
 [46] gmodels_2.18.1           Rcpp_1.0.2               slam_0.1-45             
 [49] spdep_1.1-2              gdata_2.18.0             nlme_3.1-141            
 [52] DelayedMatrixStats_1.7.1 lmtest_0.9-37            stringr_1.4.0           
 [55] globals_0.12.4           ps_1.3.0                 mime_0.7                
 [58] irlba_2.3.3              gtools_3.8.1             devtools_2.1.0          
 [61] future_1.14.0            LearnBayes_2.15.1        zlibbioc_1.31.0         
 [64] MASS_7.3-51.4            zoo_1.8-6                scales_1.0.0            
 [67] promises_1.0.1           expm_0.999-4             RColorBrewer_1.1-2      
 [70] gridExtra_2.3            memoise_1.1.0            reticulate_1.13         
 [73] pbapply_1.4-1            ggplot2_3.2.1            Matrix.utils_0.9.7      
 [76] stringi_1.4.3            desc_1.2.0               e1071_1.7-2             
 [79] boot_1.3-23              pkgbuild_1.0.4           spData_0.3.0            
 [82] rlang_0.4.0              pkgconfig_2.0.2          bitops_1.0-6            
 [85] rsample_0.0.5            lattice_0.20-38          purrr_0.3.2             
 [88] sf_0.7-6                 htmlwidgets_1.3          processx_3.4.1          
 [91] tidyselect_0.2.5         plyr_1.8.4               magrittr_1.5            
 [94] R6_2.4.0                 generics_0.0.2           DBI_1.0.0               
 [97] pillar_1.4.2             withr_2.1.2              units_0.6-3             
[100] sp_1.3-1                 RCurl_1.95-4.12          tibble_2.1.3            
[103] crayon_1.3.4             plotly_4.9.0             viridis_0.5.1           
[106] usethis_1.5.1            grid_3.6.1               data.table_1.12.2       
[109] callr_3.3.1              digest_0.6.20            classInt_0.3-1          
[112] pbmcapply_1.5.0          xtable_1.8-4             tidyr_0.8.3             
[115] httpuv_1.5.1             RcppParallel_4.4.3       munsell_0.5.0           
[118] viridisLite_0.3.0        sessioninfo_1.1.1 
```
